<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D MLP Visualizer & Dashboard</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <style>
        :root {
            --primary: #6366f1; /* Indigo */
            --bg: #0f172a;      /* Dark Slate */
            --card: #1e293b;    /* Slate 800 */
            --text: #f8fafc;    /* Slate 50 */
            --accent: #38bdf8;  /* Sky Blue */
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 { margin-bottom: 5px; color: var(--accent); letter-spacing: -0.5px; }
        p.subtitle { color: #94a3b8; margin-bottom: 25px; font-weight: 300; }

        .main-layout {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            max-width: 1400px;
            width: 100%;
            justify-content: center;
            align-items: flex-start;
        }

        /* --- Panel Styling --- */
        .panel {
            background: var(--card);
            padding: 25px;
            border-radius: 16px;
            border: 1px solid #334155;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.5);
        }

        .controls-panel {
            flex: 1;
            min-width: 340px;
            max-width: 400px;
        }

        .graph-panel {
            flex: 2;
            min-width: 500px;
            height: 650px; 
            padding: 5px;
            position: relative;
        }

        /* --- Form Elements --- */
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 8px; font-weight: 600; font-size: 0.85rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.05em; }
        
        select, input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #475569;
            border-radius: 8px;
            font-size: 1rem;
            background: #0f172a;
            color: white;
        }
        select:focus, input:focus { outline: none; border-color: var(--accent); }

        /* --- Slider --- */
        input[type="range"] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
        }

        /* --- Buttons --- */
        .buttons { display: flex; gap: 10px; margin-top: 25px; }
        button {
            flex: 1; padding: 12px; border: none; border-radius: 8px;
            font-weight: 700; font-size: 0.9rem; cursor: pointer;
            text-transform: uppercase; letter-spacing: 0.5px;
            transition: transform 0.1s;
        }
        #trainBtn { background: var(--primary); color: white; }
        #resetBtn { background: #334155; color: white; }
        button:hover { filter: brightness(1.1); }
        button:active { transform: scale(0.98); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* --- Dashboard & Stats --- */
        .dashboard {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #334155;
        }
        
        .stat-row { 
            display: flex; justify-content: space-between; 
            margin-bottom: 8px; 
            font-family: 'Roboto Mono', monospace; 
            font-size: 0.9rem; 
        }
        .stat-val { color: var(--accent); }

        /* Parameter Table */
        .param-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.85rem;
        }
        .param-table th { 
            text-align: left; color: #64748b; 
            font-size: 0.75rem; 
            border-bottom: 1px solid #334155; 
            padding-bottom: 5px; 
        }
        .param-table td { padding: 6px 0; border-bottom: 1px solid #1e293b; }
        .w-val { color: #a5b4fc; } /* Weight color */
        .b-val { color: #fca5a5; } /* Bias color */

        /* Status Badge */
        #statusBadge {
            display: block;
            margin-top: 15px;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            font-weight: bold;
            font-size: 0.85rem;
            background: #334155;
        }
    </style>
</head>
<body>

    <h1>Neural Network Studio</h1>
    <p class="subtitle">Interactive 3D Visualization of Perceptron Convergence</p>

    <div class="main-layout">
        <div class="panel controls-panel">
            <div class="control-group">
                <label>Problem Type</label>
                <select id="gateSelect">
                    <option value="XOR">XOR (Non-Linear / MLP)</option>
                    <option value="AND">AND (Linear)</option>
                    <option value="OR">OR (Linear)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Learning Rate ($\alpha$)</label>
                <input type="number" id="learningRate" value="0.1" step="0.01" min="0.001" max="1">
            </div>

            <div class="control-group">
                <label>Speed</label>
                <input type="range" id="speedSlider" min="1" max="50" value="10">
            </div>

            <div class="buttons">
                <button id="trainBtn">Train</button>
                <button id="resetBtn">Reset</button>
            </div>

            <div class="dashboard">
                <div class="stat-row"><span>Epoch:</span> <span id="epochDisplay" class="stat-val">0</span></div>
                <div class="stat-row"><span>Loss (MSE):</span> <span id="lossDisplay" class="stat-val">0.0000</span></div>
                
                <div id="statusBadge">Ready</div>

                <div id="paramContainer">
                    <div style="margin-top: 20px; font-size: 0.8rem; font-weight: bold; color: #94a3b8; text-transform: uppercase;">
                        Network Parameters
                    </div>
                    <table class="param-table">
                        <thead>
                            <tr>
                                <th>Layer</th>
                                <th>Weights ($w_1, w_2$)</th>
                                <th>Bias ($b$)</th>
                            </tr>
                        </thead>
                        <tbody id="paramBody">
                            </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="panel graph-panel" id="plotDiv"></div>
    </div>

    <script>
        // --- State Management ---
        const gates = {
            AND:  { data: [[0,0,0], [0,1,0], [1,0,0], [1,1,1]], type: 'single' },
            OR:   { data: [[0,0,0], [0,1,1], [1,0,1], [1,1,1]], type: 'single' },
            XOR:  { data: [[0,0,0], [0,1,1], [1,0,1], [1,1,0]], type: 'mlp' }
        };

        let state = {
            gate: 'XOR',
            running: false,
            epoch: 0,
            weights: [0,0], bias: 0, // Single Perceptron
            // MLP (2-2-1): Hidden[Neuron][w1,w2], HiddenBias[n], Output[w1,w2], OutputBias
            hiddenW: [[0,0],[0,0]], hiddenB: [0,0],
            outW: [0,0], outB: 0
        };
        
        let animFrame;

        // --- Math Helpers ---
        const sigmoid = x => 1 / (1 + Math.exp(-x));
        const dSigmoid = y => y * (1 - y); // derivative using output y
        const rand = () => Math.random() * 2 - 1; // -1 to 1

        // --- Core Logic ---
        function init() {
            resetNetwork();
            render();
        }

        function resetNetwork() {
            state.running = false;
            cancelAnimationFrame(animFrame);
            state.epoch = 0;
            
            // Randomize parameters
            state.weights = [rand(), rand()]; 
            state.bias = rand();

            state.hiddenW = [[rand(), rand()], [rand(), rand()]];
            state.hiddenB = [rand(), rand()];
            state.outW = [rand(), rand()];
            state.outB = rand();

            document.getElementById('trainBtn').disabled = false;
            document.getElementById('statusBadge').innerText = "Ready";
            document.getElementById('statusBadge').style.background = "#334155";
            
            updateUI(0);
            render();
        }

        function trainStep(lr) {
            const config = gates[state.gate];
            let totalError = 0;

            // Iterate through all data points
            for(let pt of config.data) {
                const [x1, x2, target] = pt;

                if (config.type === 'single') {
                    // Linear Perceptron Rule
                    const y = (x1 * state.weights[0] + x2 * state.weights[1] + state.bias) >= 0 ? 1 : 0;
                    const err = target - y;
                    
                    if (err !== 0) {
                        state.weights[0] += lr * err * x1;
                        state.weights[1] += lr * err * x2;
                        state.bias += lr * err;
                        totalError += Math.abs(err);
                    }

                } else {
                    // MLP Backpropagation
                    // 1. Forward
                    const h1 = sigmoid(x1*state.hiddenW[0][0] + x2*state.hiddenW[0][1] + state.hiddenB[0]);
                    const h2 = sigmoid(x1*state.hiddenW[1][0] + x2*state.hiddenW[1][1] + state.hiddenB[1]);
                    const out = sigmoid(h1*state.outW[0] + h2*state.outW[1] + state.outB);

                    // 2. Error
                    const err = target - out;
                    totalError += (err * err);

                    // 3. Backward
                    const dOut = err * dSigmoid(out);
                    
                    const dH1 = dOut * state.outW[0] * dSigmoid(h1);
                    const dH2 = dOut * state.outW[1] * dSigmoid(h2);

                    // 4. Update
                    state.outW[0] += lr * dOut * h1;
                    state.outW[1] += lr * dOut * h2;
                    state.outB    += lr * dOut;

                    state.hiddenW[0][0] += lr * dH1 * x1;
                    state.hiddenW[0][1] += lr * dH1 * x2;
                    state.hiddenB[0]   += lr * dH1;

                    state.hiddenW[1][0] += lr * dH2 * x1;
                    state.hiddenW[1][1] += lr * dH2 * x2;
                    state.hiddenB[1]   += lr * dH2;
                }
            }
            return totalError / config.data.length;
        }

        function loop() {
            if(!state.running) return;

            const lr = parseFloat(document.getElementById('learningRate').value);
            const speed = parseInt(document.getElementById('speedSlider').value);
            const isMLP = gates[state.gate].type === 'mlp';
            
            // Speed Multiplier: MLP needs more steps to visualize change
            const steps = isMLP ? speed * 10 : speed; 
            
            let loss = 0;
            for(let i=0; i<steps; i++) {
                state.epoch++;
                loss = trainStep(lr);
            }

            updateUI(loss);
            
            // Re-render graph every frame (or skip frames if too slow)
            render();

            // Convergence Check
            if ((!isMLP && loss === 0) || (isMLP && loss < 0.002)) {
                state.running = false;
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('statusBadge').innerText = `Converged in ${state.epoch}`;
                document.getElementById('statusBadge').style.background = "#22c55e"; // Green
            } else if (state.epoch > 50000) {
                state.running = false;
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('statusBadge').innerText = "Timeout";
            } else {
                animFrame = requestAnimationFrame(loop);
            }
        }

        // --- UI & Rendering ---
        function updateUI(loss) {
            document.getElementById('epochDisplay').innerText = state.epoch;
            document.getElementById('lossDisplay').innerText = loss.toFixed(5);
            
            // Update Parameter Table
            const fmt = n => (n>=0 ? '+' : '') + n.toFixed(2);
            const tbody = document.getElementById('paramBody');
            
            if (gates[state.gate].type === 'mlp') {
                tbody.innerHTML = `
                    <tr>
                        <td>Hidden 1</td>
                        <td class="w-val">${fmt(state.hiddenW[0][0])}, ${fmt(state.hiddenW[0][1])}</td>
                        <td class="b-val">${fmt(state.hiddenB[0])}</td>
                    </tr>
                    <tr>
                        <td>Hidden 2</td>
                        <td class="w-val">${fmt(state.hiddenW[1][0])}, ${fmt(state.hiddenW[1][1])}</td>
                        <td class="b-val">${fmt(state.hiddenB[1])}</td>
                    </tr>
                    <tr>
                        <td>Output</td>
                        <td class="w-val">${fmt(state.outW[0])}, ${fmt(state.outW[1])}</td>
                        <td class="b-val">${fmt(state.outB)}</td>
                    </tr>
                `;
            } else {
                tbody.innerHTML = `
                    <tr>
                        <td>Perceptron</td>
                        <td class="w-val">${fmt(state.weights[0])}, ${fmt(state.weights[1])}</td>
                        <td class="b-val">${fmt(state.bias)}</td>
                    </tr>
                `;
            }
        }

        function render() {
            const type = gates[state.gate].type;
            const data = gates[state.gate].data;
            const traces = [];

            // 1. Data Points (Target)
            const x0=[], y0=[], z0=[];
            const x1=[], y1=[], z1=[];
            
            data.forEach(d => {
                // If MLP, z is target. If Single, z is just visually separated
                const zVal = type === 'mlp' ? d[2] : (d[2]===0 ? 0 : 1);
                if (d[2] === 0) { x0.push(d[0]); y0.push(d[1]); z0.push(zVal); }
                else { x1.push(d[0]); y1.push(d[1]); z1.push(zVal); }
            });

            const markerStyle = { size: 10, line: { color: 'white', width: 1 }, opacity: 1 };
            
            // 2. Decision Surface / Boundary
            if (type === 'mlp') {
                // 3D Surface
                const N = 20; // Grid resolution
                const xGrid=[], yGrid=[], zGrid=[];
                
                for(let i=0; i<=N; i++) xGrid.push(i/N * 1.2 - 0.1);
                for(let i=0; i<=N; i++) yGrid.push(i/N * 1.2 - 0.1);

                for(let y of yGrid) {
                    let row = [];
                    for(let x of xGrid) {
                        const h1 = sigmoid(x*state.hiddenW[0][0] + y*state.hiddenW[0][1] + state.hiddenB[0]);
                        const h2 = sigmoid(x*state.hiddenW[1][0] + y*state.hiddenW[1][1] + state.hiddenB[1]);
                        row.push(sigmoid(h1*state.outW[0] + h2*state.outW[1] + state.outB));
                    }
                    zGrid.push(row);
                }

                traces.push({
                    type: 'surface',
                    x: xGrid, y: yGrid, z: zGrid,
                    showscale: false,
                    opacity: 0.9,
                    colorscale: 'Viridis',
                    cmin: 0, cmax: 1
                });
                
                // Add points on top (using Scatter3D)
                traces.push({
                    type: 'scatter3d', mode: 'markers', name: 'Target 0',
                    x: x0, y: y0, z: z0, marker: { ...markerStyle, color: '#ef4444', symbol: 'circle-open' }
                });
                traces.push({
                    type: 'scatter3d', mode: 'markers', name: 'Target 1',
                    x: x1, y: y1, z: z1, marker: { ...markerStyle, color: '#22c55e' }
                });

                const layout = {
                    margin: { t: 0, b: 0, l: 0, r: 0 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    scene: {
                        xaxis: { title: 'Input 1', color: 'white' },
                        yaxis: { title: 'Input 2', color: 'white' },
                        zaxis: { title: 'Output', range: [0, 1], color: 'white' },
                        camera: { eye: { x: 1.5, y: 1.5, z: 1.2 } },
                        aspectmode: 'manual', aspectratio: { x: 1, y: 1, z: 0.6 }
                    },
                    showlegend: false
                };
                Plotly.react('plotDiv', traces, layout);

            } else {
                // 2D Line
                // Line Eq: w1*x + w2*y + b = 0  ->  y = -(w1*x + b)/w2
                const lineX = [-0.5, 1.5];
                let lineY = [-2, 2];
                if (Math.abs(state.weights[1]) > 0.001) {
                    lineY = lineX.map(x => -(state.weights[0]*x + state.bias)/state.weights[1]);
                }

                traces.push({
                    type: 'scatter', mode: 'markers', name: '0',
                    x: x0, y: y0, marker: { ...markerStyle, color: '#ef4444', size: 14 }
                });
                traces.push({
                    type: 'scatter', mode: 'markers', name: '1',
                    x: x1, y: y1, marker: { ...markerStyle, color: '#22c55e', size: 14 }
                });
                traces.push({
                    type: 'scatter', mode: 'lines', name: 'Boundary',
                    x: lineX, y: lineY, line: { color: 'white', dash: 'dash' }
                });

                const layout = {
                    margin: { t: 40, b: 40, l: 40, r: 40 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    xaxis: { range: [-0.2, 1.2], color: 'white', title: 'Input 1' },
                    yaxis: { range: [-0.2, 1.2], color: 'white', title: 'Input 2', scaleanchor: 'x' },
                    showlegend: false
                };
                Plotly.react('plotDiv', traces, layout);
            }
        }

        // --- Listeners ---
        document.getElementById('trainBtn').addEventListener('click', () => {
            state.running = true;
            document.getElementById('trainBtn').disabled = true;
            document.getElementById('statusBadge').innerText = "Training...";
            document.getElementById('statusBadge').style.background = "#6366f1"; // Indigo
            loop();
        });

        document.getElementById('resetBtn').addEventListener('click', init);
        
        document.getElementById('gateSelect').addEventListener('change', (e) => {
            state.gate = e.target.value;
            init();
        });

        document.getElementById('learningRate').addEventListener('input', () => {
           // Live update allowed
        });

        // Start
        init();

    </script>
</body>
</html>
